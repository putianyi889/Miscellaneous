# 扫雷中一格是op或op边缘的概率

## 理论
此数据和is中的平均bv数直接相关，因为$`P(\text{op})+P(\text{op边缘})+P(\text{is})+P(\text{雷})=1`$。由于扫雷中绝大多数bv都在is中（猜想），这个结论可以用来估算某个参数下的bv分布。

一格是op，当且仅当它及它周围的8格，共9格都不是雷。一格是op或op边缘，当且仅当它及它周围的8格，共9格至少有一个是op。这就说明了要解决标题提出的问题，只需要考虑一格周围的$`5\times 5`$区域，而这个大小是可以用程序穷举的。

穷举的内容是$`5\times 5`$区域中的所有可能的雷的排布（0-25雷），对每个雷数对应的满足条件（中心格是op或op边缘）的排布进行计数，得到26个常数$`a_0,...,a_{25}`$。只需要用这些常数就可以快速计算宽$`w`$，高$`h`$，雷数$`m`$的情况下某一格满足条件的概率为
$$\sum_{k=0}^{25}a_k\frac{\binom{25}{k}\binom{hw-25}{m-k}}{\binom{hw}{m}}$$

如果区域超出了雷区边界，则对应的格数需要变化，整体求解过程类似，不赘述。因为计算的常数是由扫雷规则决定的，只需要一次计算就可以永久使用，而且穷举量也不大，所以无需考虑程序的性能。

## 程序代码
```julia
# Julia
isop1(n) = n & 0b11100_11100_11100_00000_00000
isop2(n) = n & 0b01110_01110_01110_00000_00000
isop3(n) = n & 0b00111_00111_00111_00000_00000
isop4(n) = n & 0b00000_11100_11100_11100_00000
isop5(n) = n & 0b00000_01110_01110_01110_00000
isop6(n) = n & 0b00000_00111_00111_00111_00000
isop7(n) = n & 0b00000_00000_11100_11100_11100
isop8(n) = n & 0b00000_00000_01110_01110_01110
isop9(n) = n & 0b00000_00000_00111_00111_00111
isop(n) = any(iszero, (isop1(n),isop2(n),isop3(n),isop4(n),isop5(n),isop6(n),isop7(n),isop8(n),isop9(n)))

countcenter = zeros(Int, 26)
countcenteredge = zeros(Int, 21)
countedge = zeros(Int, 16)
countedgecorner = zeros(Int, 13)
countcentercorner = zeros(Int, 17)
countcorner = zeros(Int, 10)

for n in 0b00000_00000_00000_00000_00000:0b11111_11111_11111_11111_11111
    if isop(n)
        countcenter[count_ones(n)+1] += 1
    end
    if iszero(n & 0b11111_00000_00000_00000_00000) && isop(n)
        countcenteredge[count_ones(n)+1] += 1
    end
    if iszero(n & 0b11111_11111_00000_00000_00000) && isop(n | 0b11111_00000_00000_00000_00000)
        countedge[count_ones(n)+1] += 1
    end
    if iszero(n & 0b11111_11111_10000_10000_10000) && isop(n | 0b11111_00000_00000_00000_00000)
        countedgecorner[count_ones(n)+1] += 1
    end
    if iszero(n & 0b11111_10000_10000_10000_10000) && isop(n)
        countcentercorner[count_ones(n)+1] += 1
    end
    if iszero(n & 0b11111_11111_11000_11000_11000) && isop(n | 0b11111_10000_10000_10000_10000)
        countcorner[count_ones(n)+1] += 1
    end
end
```

- 用一个25位的整数`n`表示这25格中的雷的排布。
- `isop(1-9)`分别对中心9格周围进行位提取，若结果是0（用`iszero`检测）则对应格是op。
- `isop`判断排布`n`的中心是op或op边缘。
- 如果$`5\times 5`$区域涉及雷区边缘则需要修改一些统计条件。一共分了六种情况：
  - `center`：区域全部在雷区中，雷区内25格
  - `centeredge`：第一行在雷区外，雷区内20格
  - `edge`：前两行在雷区外，雷区内15格
  - `edgecorner`：前两行和第一列在雷区外，雷区内12格
  - `centercorner`：第一行和第一列在雷区外，雷区内16格
  - `corner`：前两行和前两列在雷区外，雷区内9格
  每种情况都用一个数组存储结果。因为每种情况对应的区域大小不同，数组长度也就不同。数组的第`k`项（Julia数组索引从1开始）表示区域中有`k-1`雷且区域中心是op或op边缘的样本数。
- 对于25格的所有雷的排布进行穷举。因为问题规模很小，整个程序不到1秒钟运行完毕，所以为了可读性牺牲性能，分别用六个`if`分别暴力判断六种情况。

## 程序运行结果
```julia
countcenter = [1, 24, 270, 1800, 7802, 23356, 50482, 81320, 99692, 94088, 68568, 38368, 16224, 5028, 1080, 144, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0]
countcenteredge = [1, 19, 166, 825, 2573, 5462, 8381, 9658, 8509, 5731, 2904, 1071, 271, 42, 3, 0, 0, 0, 0, 0, 0]
countedge = [1, 13, 66, 182, 308, 336, 238, 106, 27, 3, 0, 0, 0, 0, 0, 0]
countedgecorner = [1, 10, 37, 72, 84, 62, 29, 8, 1, 0, 0, 0, 0]
countcentercorner = [1, 15, 101, 365, 803, 1204, 1295, 1017, 583, 240, 68, 12, 1, 0, 0, 0, 0]
countcorner = [1, 5, 10, 10, 5, 1, 0, 0, 0, 0]
```
