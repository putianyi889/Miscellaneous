# 录像压缩算法探讨

目前流通的扫雷录像格式都比较简单粗暴，编码方式类似于图像格式中的`bmp`，所以冗余信息极多，即使用通用的7z压缩算法也可以轻松达到20%以内的压缩率。若针对扫雷设计专有的压缩算法，可进一步获得更快的压缩/解压速度以及更好的压缩率。

## 雷图压缩

avf用稀疏矩阵的方式存储雷图，每个雷占2字节，分别表示行列坐标。若简单地用01串表示非雷和雷，则每格占1位。显然avf方案只有在雷密度低于1/16时才有收益。即使考虑到多数情况下一个坐标并不需要用到8位，稀疏矩阵方案也仅在初级中有收益，此时每个雷占6位，10个雷共60位，略小于用01串表示所需的64位。因此结论是使用01串存储雷图即可。

## 鼠标事件压缩
一个录像中的鼠标事件组成一个结构体数组，每个结构体是单个的鼠标事件。

### avf鼠标事件分析
avf的鼠标事件格式是`操作+坐标+时间`，
- 操作信息占1字节
- xy坐标各2字节
- 时间占3字节，整数部分2字节+小数部分1字节

操作信息占1字节对于Arbiter支持的操作来说显然浪费了，但是考虑到未来的发展（键盘操作、组合键等），1字节的操作信息未必够用。2字节支持的最大坐标65536像素/4096格，已经远远超出了目前Windows和显卡支持的最大分辨率。1字节的小数部分显然无法支持到毫秒。

### 通用鼠标事件结构
操作+坐标+时间应当成为未压缩的标准事件结构。事实上这个结构足以应对所有电子游戏。对于未压缩录像格式，存在争议的应当是每个部分的位数，尤其是对于操作和时间。然而对于压缩格式来说，这些都不是问题。

鼠标事件的信息冗余体现在
- 操作方式受限，例如一般不可能有连续两次左键按下的事件。
- 操作的稀疏性：和采样率相比，点击频率是相当低的，也就是说绝大多数操作都是移动。
- 时空的连续性：相邻两个事件的坐标与时间差值（分别简记为dx, dy, dt）是相当小的数字，在采样率增加时更是如此。另外，dt不为负。

### 时空差分压缩
下图是我的一局avf中级录像的dx和dy

![HS0L)XU 9Q{M)%1K$Z V8TS](https://github.com/putianyi889/Miscellaneous/assets/44583944/0e680fa4-59a3-4da6-b9aa-3f023105712d)

可以看出，dx和dy几乎全部分布在-1到+1，极少数达到了±2。考虑到我是移动偏慢的选手，其他人也许可以达到更高的值，但是无论如何，dx和dy的压缩难度肯定是远远低于x和y。

下图是同一局录像的dt，更多样了，但是熵仍然是远低于t，且绝大部分dt都是0和0.01，这是avf支持的最小时间差。

![H8)}%RQ2LN~I6X PJVK~JXB](https://github.com/putianyi889/Miscellaneous/assets/44583944/b3607a5b-3fb1-477b-bd4e-e50383d0352a)

所以扫雷事件的时空差分压缩算法总结为：
- 存储一次xyt的初值
- 依次计算dx,dy,dt
- 将dx,dy,排到一个数组里，dt排进另一个数组
- 用哈夫曼算法对两个数组分别压缩

使用哈夫曼压缩的一个重要优点是对于原始数据类型没有限制：无论是长整数还是短整数，压缩后的大小都是一致的。

### 空间差分压缩的傻瓜方法
分析dx和dy的分布可以发现
- 0大约有一半
- ±1大约各四分之一
- 其余值数量很少

所以可以仿照哈夫曼编码，用0表示0或其他，10表示-1，11表示1，然后另外用一个稀疏向量存储其余的值及其位置。忽略稀疏向量所占的空间，压缩率大约是1.5/16=9.4%。

注意：上述分布规律仅适用于Arbiter 0.52.3版本。更早的版本采样率低得多。

### 操作序列压缩
由于操作的稀疏性，首先应当用稀疏向量的方式存储非移动的操作序列，即操作+索引。和移动事件比起来，操作事件很少，所以这一部分的压缩优先级不高。

操作就那么几种（虽然未来可能扩充），所以可以按操作分类，将同操作的索引分别排成数组，然后打上相应操作的标签，这样可以省掉和每个事件绑定的一个操作参数。前文已经讨论过这些没有压缩必要。

每个键的按下和抬起必须是交替进行的，所以同一个键的按下和抬起操作可以合并。索引是单调的，所以依然可以用计算差分的方式压缩。虽然计算差分不能有效减少数据的熵，但是可以有效减少值的大小，这样可以用更少的位数来存储。
